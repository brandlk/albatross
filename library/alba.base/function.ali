use predicate end

A: ANY
B: ANY

immutable
    class FUNCTION[A,B]
inherit
    ghost ANY
end


{: Basic functions
   =============== :}

domain(f:A->B): ghost {A}

consistent (f,g:A->B): ghost BOOLEAN
        -- Do 'f' and 'g' have the same values on its common domain
    -> all(x) x in f.domain  ==>  x in g.domain  ==> f(x) = g(x)


(=) (f,g:A->B): ghost BOOLEAN
    -> f.domain = g.domain and consistent(f,g)

undefined: (A->B)


is_total (f:A->B): ghost BOOLEAN
    -> f.domain.is_universal


all(f,g:A->B)
    ensure
        consistent(undefined,f)
        consistent(f,g) ==> consistent(g,f)
        consistent(f,f)
        f = f
    end



{: Range, image and preimage
   ========================= :}


range (f:A->B): ghost {B}
        -- The range of the function 'f'.
    -> {y: some(x) x in f.domain and f(x) = y}

[] (f:A->B, p:{A}): ghost {B}
        -- f[p] is the image of the set 'p' under the function 'f'.
    -> {y: some(x) x in p and x in f.domain and f(x) = y}


preimage (q:{B}, f:A->B): ghost {A}
     -> {x: x in f.domain and f(x) in q}


all(x:A, p,q:{A}, f:A->B)
    ensure
       x in f.domain ==> f(x) in f.range

       f[f.domain] <= f.range
       f.range <= f[f.domain]

       f.domain <= f.range.preimage(f)
       f.range.preimage(f) <= f.domain

       p <= q ==> f[p] <= f[q]
    end
