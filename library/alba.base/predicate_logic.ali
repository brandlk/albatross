use
    boolean_logic
    predicate
end


G: ANY

all(a,b,c:G)
    ensure
        a = b  ==>  b = a
        a = b  ==>  b = c  ==>   a = c
        {a} /= 0
    end

all(x:G,p,q,r:G?)
    ensure
        p <= p
        (p <= q) ==> (q <= p) ==> (p = q)
        (p <= q) ==> (q <= r) ==> (p <= r)


        p <= q ==> p * q = p
        q <= p ==> p + q = p

        p * p = p
        p * q = q * p
        (p * q) * r = p * (q * r)

        p + p = p
        p = 0 + p
        p + q = q + p
        (p + q) + r = p + (q + r)

        (some(x) p(x)) ==>  p /= 0

        p /= 0         ==> some(x) p(x)

        p /= 0 ==> p + q /= 0

        -- De Morgan
        not (some(x) x in p) ==> x /in p
        not (all(x)  x in p) ==> (some(x) x /in p)
        (all(x)  x /in p)    ==> not (some(x) x in p)
        (some(x) x /in p)    ==> not (all(x)  x in p)
    end


all(x:G,p:G?)
    ensure
        p(x) ==> {x} <= p
    end

all(p,q:G?)
    require
        some(x) p(x)
        p <= q
    ensure
        some(x) q(x)
    end


all(ps:G??)
    ensure
        (*ps).is_infimum(ps)
        (+ps).is_supremum(ps)
    end
