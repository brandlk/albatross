use
    function
    tuple
    predicate_logic
end

A: ANY
B: ANY



{: General properties
   ================== :}


all(f,g:A->B)
    ensure
        disjoint(f.domain, g.domain) ==> consistent(f,g)
    end



{: Override
   ======== :}

(+) (f:A->B, e:(A,B)): (A->B)
    -> agent (a:A): B
           require
               a = e.first or a in f.domain
           ensure
               -> if a = e.first then e.second else f(a) end
           end


(+) (f,g:A->B): ghost (A->B)
    -> agent (a:A): B
           require
               a in (g.domain + f.domain)
           ensure
               -> if a in g.domain then g(a) else f(a) end
           end


all(f,g:A->B, a,x:A, b:B)
    ensure
        (f + (a,b))(a) = b
        x in f.domain ==> x /= a ==> (f + (a,b))(x) = f(x)

        x in g.domain ==> (f + g)(x) = g(x)
        consistent(f,g) ==> x in f.domain ==> (f + g)(x) = f(x)

        consistent(f,g) ==> f + g = g + f
    end




{: Order Structure
   =============== :}

(<=) (f,g:A->B): ghost BOOLEAN
        -- Is 'f' a subfunction of 'g'?
    -> f.domain <= g.domain
       and
       consistent(f,g)


(<) (f,g:A->B): ghost BOOLEAN
        -- Is 'f' a proper subfunction of 'g'?
    -> f <= g
       and
       some(a) a in g.domain and a /in f.domain


all(f,g,h:A->B)
    ensure
        f <= f                              -- reflexive
        f <= g  ==>  g <= h  ==> f <= h     -- transitive
        f <= g  ==>  g <= f  ==> f = g      -- antisymmetric

        f < g ==> f /= g
        f <= g ==> f /= g ==> f < g

        g <= f + g
        consistent(f,g) ==> f <= f + g

        f <= h  ==>  g <= h  ==>  consistent(f,g)
        consistent(f,g) ==> (some(h) f <= h and g <= h)
    end





{: Domain restriction
   ================== :}


(|) (f:A->B, p:{A}): (A->B)
        -- The function 'f' whose domain is restricted to the arguments which are
        -- also in 'p'.
    -> agent (a:A):B
           require
               a in f.domain
               a in p
           ensure
               -> f(a)
           end





{: Injectivity
   ===========

   A function is injective if it is one to one. I.e. each value in the range of
   the function has a unique origin.

:}


is_injective (f:A->B): ghost BOOLEAN
    -> all(x,y) x in f.domain
                ==> y in f.domain
                ==> f(x) = f(y)
                ==> x = y



all(f,g:A->B, p:{A})
    ensure
        f.is_injective ==> (f|p).is_injective

        f.is_injective
        ==> g.is_injective
        ==> disjoint(f.domain,g.domain)
        ==> disjoint(f.range, g.range)
        ==> (f + g).is_injective
    end



{: The inverse of a function
   ========================= :}


preimage(b:B, f:A->B): ghost A
        -- The argument of the injective function 'f' which maps to 'b'.
    require
        f.is_injective
        b in f.range
    ensure
        Result in f.domain
        f(Result) = b
    end


inverse (f:A->B): ghost (B -> A)
        -- The inverse of the injective function 'f'.
    require
        f.is_injective
    ensure
        Result.domain = f.range
        all(x) x in f.domain ==> Result(f(x)) = x
    end
