use any end

G: ANY

class PREDICATE[G] end

class
    PREDICATE[G]
inherit
    ghost ANY
end


(in)  (a:G, p:{G}): BOOLEAN
        -- Is 'a' an element of the set 'p'?
        --     Note: The expressions 'a in p' and 'p(a)' are equivalent

(/in) (a:G, p:{G}): BOOLEAN
        -- Is 'a' not an element of the set 'p'?
    -> not p(a)

(<=) (p,q:{G}): ghost BOOLEAN
        -- Is 'p' a subset of 'q'?
    -> all(x) x in p ==> x in q

(=)  (p,q:{G}): ghost BOOLEAN
        -- Are 'p' and 'q' equal sets?
    -> p <= q and q <= p

has_some (p:{G}): ghost BOOLEAN
        -- Does the set 'p' have elements?
    -> some(x) x in p

is_empty (p:{G}): ghost BOOLEAN
        -- Is the set 'p' empty?
    -> not p.has_some

is_universal (p:{G}): ghost BOOLEAN
        -- Is the set 'p' the universal set?
    -> all(x) x in p

empty:{G}
        -- The empty set
    = {x: false}

universal:{G}
        -- The universal set
    = {x: true}



all(a,b,c:G, p:{G})
    ensure
        p = p                        -- reflexivity
        a = b  ==>  p(a)  ==>  p(b)  -- leibniz rule

        a = b ==> b = a              -- symmetry of equality
        a = b ==> b = c ==> a = c    -- transitivity of equality

        p.is_empty ==> all(a) a /in p   -- empty set does not have elements

        (a /in p ==> false) ==> a in p  -- indirect proof
    end
